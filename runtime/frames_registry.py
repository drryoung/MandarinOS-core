from __future__ import annotations
import json
from pathlib import Path
from typing import Dict, Tuple

# This file provides ONE job:
# given engine_id + frame_id, return the path to the frame JSON file.

_REGISTRY = None

def _load_registry() -> Dict[Tuple[str, str], str]:
    """
    Loads a registry JSON file generated by your content build.
    For now, we use a simple file location:
      runtime/frames_registry.json

    Format expected:
    {
      "engine_id|frame_id": "relative/path/to/frame.json",
      ...
    }
    """
    p = Path(__file__).resolve().parent / "frames_registry.json"
    if not p.exists():
        raise FileNotFoundError(f"Missing frames registry file: {p}")

    data = json.loads(p.read_text(encoding="utf-8"))
    reg: Dict[Tuple[str, str], str] = {}
    for k, v in data.items():
        if "|" not in k:
            continue
        eid, fid = k.split("|", 1)
        reg[(eid, fid)] = str(v)
    return reg

def get_frame_path(engine_id: str, frame_id: str) -> str:
    """
    Returns absolute path to frame JSON file.
    
    Args:
        engine_id: Engine identifier
        frame_id: Frame identifier
    
    Returns:
        Absolute path to the frame JSON file
    
    Raises:
        FileNotFoundError: If registry file is missing
        KeyError: If frame is not found in registry
    """
    global _REGISTRY
    if _REGISTRY is None:
        _REGISTRY = _load_registry()

    key = (engine_id, frame_id)
    if key not in _REGISTRY:
        raise KeyError(f"Frame not found in registry: engine_id={engine_id}, frame_id={frame_id}")

    # return an absolute path so safe_load_json works no matter current working directory
    base = Path(__file__).resolve().parents[1]  # repo root
    return str((base / _REGISTRY[key]).resolve())